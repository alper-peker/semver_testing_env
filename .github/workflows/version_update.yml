name: Component-aware SemVer Workflow

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: semver-${{ github.ref }}
  cancel-in-progress: false

jobs:
  prepare_meta:
    name: Detect changed components & SemVer bump
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main'
    outputs:
      changed: ${{ steps.detect.outputs.changed }}
      bump: ${{ steps.bump.outputs.bump }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed components
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.merge_commit_sha || github.event.pull_request.head.sha }}"

          git diff --name-only "${BASE_SHA}" "${HEAD_SHA}" > changed.txt || true
          
          FRONT=$(grep -E '^frontend-code/'  changed.txt || true)
          BACK=$(grep -E '^flask-api/'       changed.txt || true)
          FUNCS=$(grep -E '^gcp-functions/'  changed.txt || true)
          INFRA=$(grep -E '^(nginx/|docker-compose|infra/)' changed.txt || true)

          OUT=""
          [[ -n "${FRONT:-}"  ]] && OUT+="${OUT:+,}fend"
          [[ -n "${BACK:-}"   ]] && OUT+="${OUT:+,}bend"
          [[ -n "${FUNCS:-}"  ]] && OUT+="${OUT:+,}func"
          [[ -n "${INFRA:-}"  ]] && OUT+="${OUT:+,}infra"

          echo "changed=${OUT}" >> "$GITHUB_OUTPUT"

      - name: Determine SemVer bump from labels
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.pull_request.labels || []).map(l => l.name);
            let bump = 'patch';
            if (labels.includes('breaking-change')) bump = 'major';
            else if (labels.includes('feature')) bump = 'minor';
            core.setOutput('bump', bump);

  compute_versions:
    name: Compute next version per component
    runs-on: ubuntu-latest
    needs: prepare_meta
    if: needs.prepare_meta.outputs.changed != ''
    outputs:
      frontend_next: ${{ steps.calc.outputs.frontend_next }}
      backend_next: ${{ steps.calc.outputs.backend_next }}
      functions_next: ${{ steps.calc.outputs.functions_next }}
      infra_next: ${{ steps.calc.outputs.infra_next }}
      global_next: ${{ steps.calc.outputs.global_next }}
    env:
      BUMP_LEVEL: ${{ needs.prepare_meta.outputs.bump }}
      CHANGED: ${{ needs.prepare_meta.outputs.changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Fetch tags
        run: git fetch --tags --force
      - name: Compute next versions
        id: calc
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${BUMP_LEVEL}"
          CHANGED="${CHANGED}"

          bump_one() {
            local prefix="$1"
            local pattern="${prefix}-v*"
            local last
            last=$(git tag --list "$pattern" | sort -V | tail -n 1 || true)
            local base="0.0.0"
            [[ -n "$last" ]] && base="${last#${prefix}-v}"
            
            IFS='.' read -r major minor patch <<< "$base"
            case "$BUMP" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch|*) patch=$((patch + 1)) ;;
            esac

            if [[ "$patch" -ge 10 ]]; then
              patch=0
              minor=$((minor + 1))
            fi
            if [[ "$minor" -ge 10 ]]; then
              minor=0
              major=$((major + 1))
            fi

            echo "${prefix}-v${major}.${minor}.${patch}"
          }

          bump_global() {
            local last
            last=$(git tag --list "v[0-9]*" | sort -V | tail -n 1 || true)
            local base="0.0.0"
            [[ -n "$last" ]] && base="${last#v}"

            IFS='.' read -r major minor patch <<< "$base"
            case "$BUMP" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch|*) patch=$((patch + 1)) ;;
            esac

            if [[ "$patch" -ge 10 ]]; then
              patch=0
              minor=$((minor + 1))
            fi
            if [[ "$minor" -ge 10 ]]; then
              minor=0
              major=$((major + 1))
            fi

            echo "v${major}.${minor}.${patch}"
          }

          GLOBAL_NEXT="$(bump_global)"
          FRONT_NEXT=""
          BACK_NEXT=""
          FUNCS_NEXT=""
          INFRA_NEXT=""

          [[ ",$CHANGED," == *",fend,"* ]] && FRONT_NEXT="$(bump_one "frontend")"
          [[ ",$CHANGED," == *",bend,"* ]] && BACK_NEXT="$(bump_one "backend")"
          [[ ",$CHANGED," == *",func,"* ]] && FUNCS_NEXT="$(bump_one "functions")"
          [[ ",$CHANGED," == *",infra,"* ]] && INFRA_NEXT="$(bump_one "infra")"

          echo "frontend_next=$FRONT_NEXT"  >> "$GITHUB_OUTPUT"
          echo "backend_next=$BACK_NEXT"    >> "$GITHUB_OUTPUT"
          echo "functions_next=$FUNCS_NEXT" >> "$GITHUB_OUTPUT"
          echo "infra_next=$INFRA_NEXT"     >> "$GITHUB_OUTPUT"
          echo "global_next=$GLOBAL_NEXT"   >> "$GITHUB_OUTPUT"

  create_and_push_tags:
    name: Create and push tags
    runs-on: ubuntu-latest
    needs: compute_versions
    if: needs.compute_versions.outputs.global_next != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions@users.noreply.github.com"
      - name: Create and push tags
        shell: bash
        run: |
          set -euo pipefail
          F_TAG="${{ needs.compute_versions.outputs.frontend_next }}"
          B_TAG="${{ needs.compute_versions.outputs.backend_next }}"
          FN_TAG="${{ needs.compute_versions.outputs.functions_next }}"
          INF_TAG="${{ needs.compute_versions.outputs.infra_next }}"
          G_TAG="${{ needs.compute_versions.outputs.global_next }}"

          [[ -n "$G_TAG" ]] && git tag -a "$G_TAG" -m "Global release"
          [[ -n "$F_TAG" ]] && git tag -a "$F_TAG" -m "Frontend release"
          [[ -n "$B_TAG" ]] && git tag -a "$B_TAG" -m "Backend release"
          [[ -n "$FN_TAG" ]] && git tag -a "$FN_TAG" -m "Functions release"
          [[ -n "$INF_TAG" ]] && git tag -a "$INF_TAG" -m "Infra release"

          git push --tags

  major_release:
    name: Create Major Global Release
    runs-on: ubuntu-latest
    needs: [prepare_meta, compute_versions, create_and_push_tags]
    if: needs.prepare_meta.outputs.bump == 'major'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes and Create Global Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_LABEL }}
          FRONT_TAG: ${{ needs.compute_versions.outputs.frontend_next }}
          BACK_TAG: ${{ needs.compute_versions.outputs.backend_next }}
          FUNCS_TAG: ${{ needs.compute_versions.outputs.functions_next }}
          INFRA_TAG: ${{ needs.compute_versions.outputs.infra_next }}
          GLOBAL_TAG: ${{ needs.compute_versions.outputs.global_next }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          set -euo pipefail
          
          TAG="$GLOBAL_TAG"

          if [[ -z "$TAG" ]]; then
            echo "No global tag found, skipping release."
            exit 0
          fi

          echo "Processing GLOBAL release for $TAG..."

          git fetch --tags --force
          
          # Find previous global tag
          PREV_TAG=""
          RELEASE_TAGS=$(gh release list --limit 100 --json tagName --jq ".[].tagName" | grep "^v[0-9]" || true)
          
          for t in $RELEASE_TAGS; do
            if [[ "$t" != "$TAG" ]]; then
              PREV_TAG="$t"
              break
            fi
          done

          DIFF_OUTPUT=""
          
          if [[ -n "$PREV_TAG" ]]; then
            echo "Creating diff from previous release: $PREV_TAG"
            DIFF_OUTPUT=$(git diff "$PREV_TAG" "$TAG" | head -c 4000 || true)
          else
            echo "No previous global release found. Collecting full commit history."
            HISTORY=$(git log --pretty=format:"- %s" "$TAG" | head -n 50 || true)
            DIFF_OUTPUT="INITIAL GLOBAL RELEASE. Full Commit History:\n$HISTORY"
          fi

          PROMPT="You are a technical writer. Generate a release note for a major GLOBAL release of the repository.
          
          Context:
          - Release Version: $TAG
          - Previous Version: ${PREV_TAG:-Initial Release}
          - PR Title: $PR_TITLE
          - PR Body: $PR_BODY
          
          Data for Summary (Global Diff OR Commit History):
          $DIFF_OUTPUT
          
          Instructions:
          Generate the release notes using EXACTLY the following format:
          
          Summary: Brief explanation of this release (mention if it is the first release).
          
          âš ï¸ Breaking Changes:
          - Detail the major breaking changes here based on the diff/PR.
          
          Changes:
          - List key features/fixes based on the provided data.
          
          Do not include raw diffs or commit hashes. Ensure the tone is professional."

          PAYLOAD=$(jq -n \
            --arg model "gpt-4o-mini" \
            --arg system "You are a helpful assistant that generates release notes." \
            --arg user "$PROMPT" \
            '{
              model: $model,
              messages: [
                {role: "system", content: $system},
                {role: "user", content: $user}
              ],
              temperature: 0.3
            }')

          RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$PAYLOAD")

          if echo "$RESPONSE" | jq -e '.error' > /dev/null; then
            echo "OpenAI API Error: $(echo $RESPONSE | jq -r '.error.message')"
            NOTES="Major release $TAG. See PR #$PR_NUMBER for details."
          else
            NOTES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          fi

          COMPONENT_INFO=""
          COMPONENT_INFO+=$'\n\n### ðŸ“¦ Component Versions\n'
          [[ -n "$FRONT_TAG" ]] && COMPONENT_INFO+="- **Frontend:** $FRONT_TAG"$'\n'
          [[ -n "$BACK_TAG" ]]  && COMPONENT_INFO+="- **Backend:** $BACK_TAG"$'\n'
          [[ -n "$FUNCS_TAG" ]] && COMPONENT_INFO+="- **Functions:** $FUNCS_TAG"$'\n'
          [[ -n "$INFRA_TAG" ]] && COMPONENT_INFO+="- **Infra:** $INFRA_TAG"$'\n'

          FINAL_NOTES="${NOTES}${COMPONENT_INFO}"

          echo "Creating GitHub Release for $TAG..."
          gh release create "$TAG" \
            --title "Release $TAG" \
            --notes "$FINAL_NOTES" \
            --repo "$REPO"
