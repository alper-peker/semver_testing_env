name: Component-aware SemVer Workflow

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: semver-${{ github.ref }}
  cancel-in-progress: false

jobs:
  prepare_meta:
    name: Detect changed components & SemVer bump
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main'
    outputs:
      changed: ${{ steps.detect.outputs.changed }}
      bump: ${{ steps.bump.outputs.bump }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed components
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.merge_commit_sha || github.event.pull_request.head.sha }}"

          git diff --name-only "${BASE_SHA}" "${HEAD_SHA}" > changed.txt || true
          
          FRONT=$(grep -E '^frontend-code/'  changed.txt || true)
          BACK=$(grep -E '^flask-api/'       changed.txt || true)
          FUNCS=$(grep -E '^gcp-functions/'  changed.txt || true)
          INFRA=$(grep -E '^(nginx/|docker-compose|infra/)' changed.txt || true)

          OUT=""
          [[ -n "${FRONT:-}"  ]] && OUT+="${OUT:+,}fend"
          [[ -n "${BACK:-}"   ]] && OUT+="${OUT:+,}bend"
          [[ -n "${FUNCS:-}"  ]] && OUT+="${OUT:+,}func"
          [[ -n "${INFRA:-}"  ]] && OUT+="${OUT:+,}infra"

          echo "changed=${OUT}" >> "$GITHUB_OUTPUT"

      - name: Determine SemVer bump from labels
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.pull_request.labels || []).map(l => l.name);
            let bump = 'patch';
            if (labels.includes('breaking-change')) bump = 'major';
            else if (labels.includes('feature')) bump = 'minor';
            core.setOutput('bump', bump);

  compute_versions:
    name: Compute next version per component
    runs-on: ubuntu-latest
    needs: prepare_meta
    if: needs.prepare_meta.outputs.changed != ''
    outputs:
      frontend_next: ${{ steps.calc.outputs.frontend_next }}
      backend_next: ${{ steps.calc.outputs.backend_next }}
      functions_next: ${{ steps.calc.outputs.functions_next }}
      infra_next: ${{ steps.calc.outputs.infra_next }}
      global_next: ${{ steps.calc.outputs.global_next }}
    env:
      BUMP_LEVEL: ${{ needs.prepare_meta.outputs.bump }}
      CHANGED: ${{ needs.prepare_meta.outputs.changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Fetch tags
        run: git fetch --tags --force
      - name: Compute next versions
        id: calc
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${BUMP_LEVEL}"
          CHANGED="${CHANGED}"

          bump_one() {
            local prefix="$1"
            local pattern="${prefix}-v*"
            local last
            last=$(git tag --list "$pattern" | sort -V | tail -n 1 || true)
            local base="0.0.0"
            [[ -n "$last" ]] && base="${last#${prefix}-v}"
            
            IFS='.' read -r major minor patch <<< "$base"
            case "$BUMP" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch|*) patch=$((patch + 1)) ;;
            esac
            echo "${prefix}-v${major}.${minor}.${patch}"
          }

          bump_global() {
            local last
            last=$(git tag --list "v[0-9]*" | sort -V | tail -n 1 || true)
            local base="0.0.0"
            [[ -n "$last" ]] && base="${last#v}"

            IFS='.' read -r major minor patch <<< "$base"
            case "$BUMP" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch|*) patch=$((patch + 1)) ;;
            esac
            echo "v${major}.${minor}.${patch}"
          }

          GLOBAL_NEXT="$(bump_global)"
          FRONT_NEXT=""
          BACK_NEXT=""
          FUNCS_NEXT=""
          INFRA_NEXT=""

          [[ ",$CHANGED," == *",fend,"* ]] && FRONT_NEXT="$(bump_one "frontend")"
          [[ ",$CHANGED," == *",bend,"* ]] && BACK_NEXT="$(bump_one "backend")"
          [[ ",$CHANGED," == *",func,"* ]] && FUNCS_NEXT="$(bump_one "functions")"
          [[ ",$CHANGED," == *",infra,"* ]] && INFRA_NEXT="$(bump_one "infra")"

          echo "frontend_next=$FRONT_NEXT"  >> "$GITHUB_OUTPUT"
          echo "backend_next=$BACK_NEXT"    >> "$GITHUB_OUTPUT"
          echo "functions_next=$FUNCS_NEXT" >> "$GITHUB_OUTPUT"
          echo "infra_next=$INFRA_NEXT"     >> "$GITHUB_OUTPUT"
          echo "global_next=$GLOBAL_NEXT"   >> "$GITHUB_OUTPUT"

  create_and_push_tags:
    name: Create and push tags
    runs-on: ubuntu-latest
    needs: compute_versions
    if: needs.compute_versions.outputs.global_next != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions@users.noreply.github.com"
      - name: Create and push tags
        shell: bash
        run: |
          set -euo pipefail
          F_TAG="${{ needs.compute_versions.outputs.frontend_next }}"
          B_TAG="${{ needs.compute_versions.outputs.backend_next }}"
          FN_TAG="${{ needs.compute_versions.outputs.functions_next }}"
          INF_TAG="${{ needs.compute_versions.outputs.infra_next }}"
          G_TAG="${{ needs.compute_versions.outputs.global_next }}"

          [[ -n "$G_TAG" ]] && git tag -a "$G_TAG" -m "Global release"
          [[ -n "$F_TAG" ]] && git tag -a "$F_TAG" -m "Frontend release"
          [[ -n "$B_TAG" ]] && git tag -a "$B_TAG" -m "Backend release"
          [[ -n "$FN_TAG" ]] && git tag -a "$FN_TAG" -m "Functions release"
          [[ -n "$INF_TAG" ]] && git tag -a "$INF_TAG" -m "Infra release"

          git push --tags

  major_release:
    name: Create Major Release
    runs-on: ubuntu-latest
    needs: [prepare_meta, compute_versions, create_and_push_tags]
    if: needs.prepare_meta.outputs.bump == 'major'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes and Create Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_LABEL }}
          FRONT_TAG: ${{ needs.compute_versions.outputs.frontend_next }}
          BACK_TAG: ${{ needs.compute_versions.outputs.backend_next }}
          FUNCS_TAG: ${{ needs.compute_versions.outputs.functions_next }}
          INFRA_TAG: ${{ needs.compute_versions.outputs.infra_next }}
          GLOBAL_TAG: ${{ needs.compute_versions.outputs.global_next }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          set -euo pipefail

          create_release() {
            local tag="$1"
            local component="$2"

            if [[ -z "$tag" ]]; then
              return
            fi

            echo "Processing release for $component ($tag)..."

            git fetch --tags --force
            
            # Previous tag bulma mantığı
            local prev_tag=""
            local pattern
            if [[ "$component" == "global" ]]; then
               pattern="^v[0-9]"
            else
               pattern="^${component}-v"
            fi
            
            local release_tags
            release_tags=$(gh release list --limit 100 --json tagName --jq ".[].tagName" | grep "$pattern" || true)
            
            for t in $release_tags; do
              if [[ "$t" != "$tag" ]]; then
                prev_tag="$t"
                break
              fi
            done

            local diff_output=""
            
            if [[ -n "$prev_tag" ]]; then
              echo "Creating diff from previous release: $prev_tag"
              diff_output=$(git diff "$prev_tag" "$tag" | head -c 3000 || true)
            else
              # WARNING: COLLECTING FULL COMMIT HISTORY
              echo "No previous release found. Collecting full commit history for initial release."
              
              local path_filter=""
              case "$component" in
                "frontend") path_filter="frontend-code/" ;;
                "backend") path_filter="flask-api/" ;;
                "functions") path_filter="gcp-functions/" ;;
                "infra") path_filter="." ;; # Infra dağınık olduğu için kök dizini baz alabiliriz
                "global") path_filter="." ;;
                *) path_filter="." ;;
              esac
              
              local history
              history=$(git log --pretty=format:"- %s" "$tag" -- "$path_filter" | head -n 50 || true)
              
              diff_output="INITIAL RELEASE. Full Commit History:\n$history"
            fi

            PROMPT="You are a technical writer. Generate a release note for a major version release of the '$component' component.
            
            Context:
            - Component: $component
            - Version: $tag
            - Previous Version: ${prev_tag:-Initial Release}
            - PR Title: $PR_TITLE
            - PR Body: $PR_BODY
            
            Data for Summary (Code Diff OR Commit History):
            $diff_output
            
            Instructions:
            Generate the release notes using EXACTLY the following format:
            
            Title: Release $tag
            Summary: Brief explanation of this release (mention if it is the first release).
            
            [Only if breaking changes exist]
            ⚠️ Breaking Changes:
            - Detail them here.
            
            Changes:
            - List features/fixes based on the provided data.
            
            Do not include raw diffs or commit hashes. Ensure the tone is professional."

            PAYLOAD=$(jq -n \
              --arg model "gpt-4o-mini" \
              --arg system "You are a helpful assistant that generates release notes." \
              --arg user "$PROMPT" \
              '{
                model: $model,
                messages: [
                  {role: "system", content: $system},
                  {role: "user", content: $user}
                ],
                temperature: 0.3
              }')

            RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "$PAYLOAD")

            if echo "$RESPONSE" | jq -e '.error' > /dev/null; then
              echo "OpenAI API Error: $(echo $RESPONSE | jq -r '.error.message')"
              NOTES="Major release for $component. See PR #$PR_NUMBER for details."
            else
              NOTES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
            fi

            echo "Creating GitHub Release for $tag..."
            gh release create "$tag" \
              --title "$tag" \
              --notes "$NOTES" \
              --repo "$REPO"
          }
          
          create_release "$GLOBAL_TAG" "global"
          create_release "$FRONT_TAG" "frontend"
          create_release "$BACK_TAG" "backend"
          create_release "$FUNCS_TAG" "functions"
          create_release "$INFRA_TAG" "infra"
