name: Component-aware SemVer Workflow

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: semver-${{ github.ref }}
  cancel-in-progress: false

jobs:
  prepare_meta:
    name: Detect changed components & SemVer bump
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main'
    outputs:
      changed: ${{ steps.detect.outputs.changed }}
      bump: ${{ steps.bump.outputs.bump }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed components
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.merge_commit_sha || github.event.pull_request.head.sha }}"

          git diff --name-only "${BASE_SHA}" "${HEAD_SHA}" > changed.txt || true
          
          FRONT=$(grep -E '^frontend-code/'  changed.txt || true)
          BACK=$(grep -E '^flask-api/'       changed.txt || true)
          FUNCS=$(grep -E '^gcp-functions/'  changed.txt || true)
          INFRA=$(grep -E '^(nginx/|docker-compose|infra/)' changed.txt || true)

          OUT=""
          [[ -n "${FRONT:-}"  ]] && OUT+="${OUT:+,}fend"
          [[ -n "${BACK:-}"   ]] && OUT+="${OUT:+,}bend"
          [[ -n "${FUNCS:-}"  ]] && OUT+="${OUT:+,}func"
          [[ -n "${INFRA:-}"  ]] && OUT+="${OUT:+,}infra"

          echo "changed=${OUT}" >> "$GITHUB_OUTPUT"

      - name: Determine SemVer bump from labels
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.pull_request.labels || []).map(l => l.name);
            let bump = 'patch';
            if (labels.includes('breaking-change')) bump = 'major';
            else if (labels.includes('feature')) bump = 'minor';
            core.setOutput('bump', bump);

  compute_versions:
    name: Compute next version per component
    runs-on: ubuntu-latest
    needs: prepare_meta
    outputs:
      frontend_next: ${{ steps.calc.outputs.frontend_next }}
      backend_next: ${{ steps.calc.outputs.backend_next }}
      functions_next: ${{ steps.calc.outputs.functions_next }}
      infra_next: ${{ steps.calc.outputs.infra_next }}
      global_next: ${{ steps.calc.outputs.global_next }}
    env:
      BUMP_LEVEL: ${{ needs.prepare_meta.outputs.bump }}
      CHANGED: ${{ needs.prepare_meta.outputs.changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Fetch tags
        run: git fetch --tags --force
      - name: Compute next versions
        id: calc
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${BUMP_LEVEL}"
          CHANGED="${CHANGED}"

          get_latest_tag() {
            local prefix="$1"
            local pattern="${prefix}-v*"
            local last
            last=$(git tag --list "$pattern" | sort -V | tail -n 1 || true)
            if [[ -z "$last" ]]; then
               echo "${prefix}-v0.0.0"
            else
               echo "$last"
            fi
          }

          bump_version() {
            local prefix="$1"
            local current_tag="$2"
            
            local base="${current_tag#${prefix}-v}"
            IFS='.' read -r major minor patch <<< "$base"
            
            case "$BUMP" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch|*) patch=$((patch + 1)) ;;
            esac

            if [[ "$patch" -ge 10 ]]; then
              patch=0
              minor=$((minor + 1))
            fi
            if [[ "$minor" -ge 10 ]]; then
              minor=0
              major=$((major + 1))
            fi

            echo "${prefix}-v${major}.${minor}.${patch}"
          }

          GLOBAL_LAST=$(git tag --list "v[0-9]*" | sort -V | tail -n 1 || echo "v0.0.0")
          GLOBAL_BASE="${GLOBAL_LAST#v}"
          IFS='.' read -r g_major g_minor g_patch <<< "$GLOBAL_BASE"
          
          case "$BUMP" in
              major) g_major=$((g_major + 1)); g_minor=0; g_patch=0 ;;
              minor) g_minor=$((g_minor + 1)); g_patch=0 ;;
              patch|*) g_patch=$((g_patch + 1)) ;;
          esac
          
          if [[ "$g_patch" -ge 10 ]]; then g_patch=0; g_minor=$((g_minor + 1)); fi
          if [[ "$g_minor" -ge 10 ]]; then g_minor=0; g_major=$((g_major + 1)); fi
          
          GLOBAL_NEXT="v${g_major}.${g_minor}.${g_patch}"

          
          FRONT_CURRENT=$(get_latest_tag "frontend")
          if [[ ",$CHANGED," == *",fend,"* ]]; then
             FRONT_NEXT=$(bump_version "frontend" "$FRONT_CURRENT")
          else
             FRONT_NEXT="$FRONT_CURRENT"
          fi

          BACK_CURRENT=$(get_latest_tag "backend")
          if [[ ",$CHANGED," == *",bend,"* ]]; then
             BACK_NEXT=$(bump_version "backend" "$BACK_CURRENT")
          else
             BACK_NEXT="$BACK_CURRENT"
          fi

          FUNCS_CURRENT=$(get_latest_tag "functions")
          if [[ ",$CHANGED," == *",func,"* ]]; then
             FUNCS_NEXT=$(bump_version "functions" "$FUNCS_CURRENT")
          else
             FUNCS_NEXT="$FUNCS_CURRENT"
          fi

          INFRA_CURRENT=$(get_latest_tag "infra")
          if [[ ",$CHANGED," == *",infra,"* ]]; then
             INFRA_NEXT=$(bump_version "infra" "$INFRA_CURRENT")
          else
             INFRA_NEXT="$INFRA_CURRENT"
          fi

          echo "frontend_next=$FRONT_NEXT"  >> "$GITHUB_OUTPUT"
          echo "backend_next=$BACK_NEXT"    >> "$GITHUB_OUTPUT"
          echo "functions_next=$FUNCS_NEXT" >> "$GITHUB_OUTPUT"
          echo "infra_next=$INFRA_NEXT"     >> "$GITHUB_OUTPUT"
          echo "global_next=$GLOBAL_NEXT"   >> "$GITHUB_OUTPUT"

  create_and_push_tags:
      name: Create and push tags
      runs-on: ubuntu-latest
      needs: compute_versions
      if: needs.compute_versions.outputs.global_next != ''
      steps:
        - name: Checkout
          uses: actions/checkout@v4
          with:
            fetch-depth: 0 
  
        - name: Configure git
          run: |
            git config user.name "github-actions[bot]"
            git config user.email "github-actions@users.noreply.github.com"
  
        - name: Create and push tags
          shell: bash
          run: |
            set -euo pipefail
            
            git fetch --tags --force
            
            TAGS_TO_PUSH=""
  
            ensure_tag() {
              local tag="$1"
              local msg="$2"
              if [[ -z "$tag" ]]; then return; fi
              
              if git rev-parse "$tag" >/dev/null 2>&1; then
                echo "Tag '$tag' already exists on remote/local. Skipping creation."
              else
                echo "Creating new tag: $tag"
                git tag -a "$tag" -m "$msg"
                # Sadece yeni oluÅŸturulan tagi listeye ekle
                TAGS_TO_PUSH="$TAGS_TO_PUSH $tag"
              fi
            }
  
            F_TAG="${{ needs.compute_versions.outputs.frontend_next }}"
            B_TAG="${{ needs.compute_versions.outputs.backend_next }}"
            FN_TAG="${{ needs.compute_versions.outputs.functions_next }}"
            INF_TAG="${{ needs.compute_versions.outputs.infra_next }}"
            G_TAG="${{ needs.compute_versions.outputs.global_next }}"
  
            ensure_tag "$G_TAG" "Global release"
            ensure_tag "$F_TAG" "Frontend release"
            ensure_tag "$B_TAG" "Backend release"
            ensure_tag "$FN_TAG" "Functions release"
            ensure_tag "$INF_TAG" "Infra release"
  
            if [[ -n "$TAGS_TO_PUSH" ]]; then
              echo "Pushing new tags: $TAGS_TO_PUSH"
              git push origin $TAGS_TO_PUSH
            else
              echo "No new tags to push."
            fi

  major_release:
    name: Create Major Global Release
    runs-on: ubuntu-latest
    needs: [prepare_meta, compute_versions, create_and_push_tags]
    if: needs.prepare_meta.outputs.bump == 'major'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes and Create Global Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_LABEL }}
          FRONT_TAG: ${{ needs.compute_versions.outputs.frontend_next }}
          BACK_TAG: ${{ needs.compute_versions.outputs.backend_next }}
          FUNCS_TAG: ${{ needs.compute_versions.outputs.functions_next }}
          INFRA_TAG: ${{ needs.compute_versions.outputs.infra_next }}
          GLOBAL_TAG: ${{ needs.compute_versions.outputs.global_next }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          set -euo pipefail
          
          TAG="$GLOBAL_TAG"

          if [[ -z "$TAG" ]]; then
            echo "No global tag found, skipping release."
            exit 0
          fi

          echo "Processing GLOBAL release for $TAG..."

          git fetch --tags --force
          
          PREV_TAG=""
          RELEASE_TAGS=$(gh release list --limit 100 --json tagName --jq ".[].tagName" | grep "^v[0-9]" || true)
          
          for t in $RELEASE_TAGS; do
            if [[ "$t" != "$TAG" ]]; then
              PREV_TAG="$t"
              break
            fi
          done

          DIFF_OUTPUT=""
          
          if [[ -n "$PREV_TAG" ]]; then
            echo "Creating diff from previous release: $PREV_TAG"
            DIFF_OUTPUT=$(git diff "$PREV_TAG" "$TAG" | head -c 4000 || true)
          else
            echo "No previous global release found. Collecting full commit history."
            HISTORY=$(git log --pretty=format:"- %s" "$TAG" | head -n 50 || true)
            DIFF_OUTPUT="INITIAL GLOBAL RELEASE. Full Commit History:\n$HISTORY"
          fi

          PROMPT="You are a technical writer. Generate a release note for a major GLOBAL release.
          
          Context:
          - Release Version: $TAG
          - Previous Version: ${PREV_TAG:-Initial Release}
          - PR Title: $PR_TITLE
          - PR Body: $PR_BODY
          
          Data for Summary (Diff/History):
          $DIFF_OUTPUT
          
          Instructions:
          Generate the release notes using EXACTLY the following format:
          
          Summary: Brief explanation of this release.
          
          âš ï¸ Breaking Changes:
          - Detail major breaking changes.
          
          Changes:
          - List key features/fixes.
          
          Do not include raw diffs or commit hashes. Professional tone."

          PAYLOAD=$(jq -n \
            --arg model "gpt-4o-mini" \
            --arg system "You are a helpful assistant that generates release notes." \
            --arg user "$PROMPT" \
            '{
              model: $model,
              messages: [
                {role: "system", content: $system},
                {role: "user", content: $user}
              ],
              temperature: 0.3
            }')

          RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$PAYLOAD")

          if echo "$RESPONSE" | jq -e '.error' > /dev/null; then
            echo "OpenAI API Error: $(echo $RESPONSE | jq -r '.error.message')"
            NOTES="Major release $TAG. See PR #$PR_NUMBER for details."
          else
            NOTES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          fi

          
          COMPONENT_INFO=""
          COMPONENT_INFO+=$'\n\nðŸ“¦ Component Versions\n'
          COMPONENT_INFO+="$FRONT_TAG"$'\n'
          COMPONENT_INFO+="$BACK_TAG"$'\n'
          COMPONENT_INFO+="$FUNCS_TAG"$'\n'
          COMPONENT_INFO+="$INFRA_TAG"$'\n'

          FINAL_NOTES="${NOTES}${COMPONENT_INFO}"

          echo "Creating GitHub Release for $TAG..."
          gh release create "$TAG" \
            --title "Release $TAG" \
            --notes "$FINAL_NOTES" \
            --repo "$REPO"
