name: Approval Command

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: read
  issues: write
  actions: write

env:
  APPROVAL_USERS: "AlperPeker, alper-peker"
  REQUIRED_APPROVALS: "2" 

jobs:
  handle-approval:
    if: startsWith(github.event.comment.body, '/approve') && github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - name: Process /approve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.issue.number;
            const user   = context.payload.comment.user.login;
            const body   = context.payload.comment.body.trim();

            if (!body.startsWith('/approve')) {
              return;
            }

            const APPROVERS = process.env.APPROVAL_USERS.split(",").map(s => s.trim());
            const REQUIRED  = parseInt(process.env.REQUIRED_APPROVALS, 10);

            if (!APPROVERS.includes(user)) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: `â›” @${user} is not authorized to approve. Allowed approvers: ${APPROVERS.join(", ")}`
              });
              return;
            }

            const comments = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 200 });
            
            const approvers = new Set(
              comments.data
                .filter(c => (c.body || "").trim().startsWith("/approve"))
                .map(c => c.user.login)
                .filter(u => APPROVERS.includes(u))
            );

            approvers.add(user);

            const labelsNow = (await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number }))
              .data.map(l => l.name);

            if (approvers.size >= REQUIRED) {
              if (!labelsNow.includes("approved")) {
                 await github.rest.issues.addLabels({
                   owner, repo, issue_number: number, labels: ["approved"]
                 });
              }
              
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: `âœ… **Approved!** Total approvals: ${approvers.size}/${REQUIRED}. (${[...approvers].map(a => "@" + a).join(", ")})`
              });

              const pr = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const headSha = pr.data.head.sha;
              core.info(`PR head sha: ${headSha}`);

              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                workflow_id: "label_enforcement.yml", 
                event: "pull_request", 
                head_sha: headSha,
                status: "failure", 
                per_page: 1
              });

              if (runs.workflow_runs.length > 0) {
                const run_id = runs.workflow_runs[0].id;
                core.info(`Found failed 'label_enforcement.yml' run ID: ${run_id}. Triggering re-run...`);

                await github.rest.actions.reRunWorkflowFailedJobs({
                  owner,
                  repo,
                  run_id: run_id
                });
                
                await github.rest.issues.createComment({
                    owner, repo, issue_number: number,
                    body: `ðŸ”„ Re-running the failed 'label-check' job now that approval is received.`
                });
              }

            } else {
              const pending = APPROVERS.filter(a => !approvers.has(a));
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: `âš ï¸ Approval recorded. Current: ${approvers.size}/${REQUIRED}. Pending: ${pending.map(a => "@" + a).join(", ")}`
              });
            }
