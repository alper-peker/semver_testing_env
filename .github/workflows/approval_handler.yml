name: Approval Command

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: write

env:
  APPROVAL_USERS: "AlperPeker, alper-peker"
  REQUIRED_APPROVALS: "2" 

jobs:
  handle-approval:
    if: startsWith(github.event.comment.body, '/approve') && github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - name: Process /approve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.issue.number;
            const user   = context.payload.comment.user.login;
            const body   = context.payload.comment.body.trim();

            if (!body.startsWith('/approve')) return;

            const APPROVERS_LIST = process.env.APPROVAL_USERS.split(",").map(s => s.trim());
            const REQUIRED  = parseInt(process.env.REQUIRED_APPROVALS, 10);

            if (!APPROVERS_LIST.includes(user)) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: `â›” @${user} is not authorized to approve. Allowed approvers: ${APPROVERS_LIST.join(", ")}`
              });
              return;
            }

            const comments = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 100 });
            let currentApprovers = new Set();
            
            for (const c of comments.data) {
              const cBody = (c.body || "").trim();
              
              if (cBody.includes("System Reset:") || cBody.includes("Previous approvals have been invalidated")) {
                currentApprovers.clear();
                continue;
              }

              if (cBody.startsWith("/approve") && APPROVERS_LIST.includes(c.user.login)) {
                currentApprovers.add(c.user.login);
              }
            }

            currentApprovers.add(user);

            const labelsNow = (await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number }))
              .data.map(l => l.name);

            if (currentApprovers.size >= REQUIRED) {
              if (!labelsNow.includes("approved")) {
                 await github.rest.issues.addLabels({
                   owner, repo, issue_number: number, labels: ["approved"]
                 });
              }
              
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: `âœ… **Approved!** Total approvals: ${currentApprovers.size}/${REQUIRED}. (${[...currentApprovers].map(a => "@" + a).join(", ")})`
              });

              const pr = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const headSha = pr.data.head.sha;

              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner, repo, workflow_id: "label_enforcement.yml", event: "pull_request", head_sha: headSha, status: "failure", per_page: 1
              });

              if (runs.workflow_runs.length > 0) {
                const run_id = runs.workflow_runs[0].id;
                await github.rest.actions.reRunWorkflowFailedJobs({ owner, repo, run_id: run_id });
                await github.rest.issues.createComment({
                    owner, repo, issue_number: number,
                    body: `ðŸ”„ Re-running the failed 'label-check' job now that approval is received.`
                });
              }

            } else {
              const pending = APPROVERS_LIST.filter(a => !currentApprovers.has(a));
              await github.rest.issues.createComment({
                owner, repo, issue_number: number,
                body: `âš ï¸ Approval recorded. Current: ${currentApprovers.size}/${REQUIRED}. Pending: ${pending.map(a => "@" + a).join(", ")}`
              });
            }
